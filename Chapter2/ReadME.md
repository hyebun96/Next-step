# Chapter2 문자열 계산기 구현을 통한 테스트와 리팩토링

계산기 코드를 통해 main()의 문제점을 파헤쳐 보자. 

</br>

## 코드의 구성 : Prodection Code + main() 
- ProdectionCode : 실제 서비스 담당
- main() : 프로그래밍을 실행하기 위한 목적, 프로덕션 코드가 정상적으로 동작하는지 확인하는 테스트 목적

</br>


📍 첫번째 문제점, 테스트를 담당하는 별도의 클래스를 추가했지만 main() 메소드 하나에서 프로덕션 코드의 여러 메소드를 동시에 테스트 하면 복잡도 증가,유지 부담

    📚 해결 방법 : Junit 내가 관심을 가지는 메소드에 대한 테스트만 진행하여 한번에 하나의 메소드만 집중 할 수 있다.
<br>

📍 두번째 문제점, 실행 결과를 눈으로 직접 확인해야 하는것
    
    📚 해결 방법 : JUnit의 assertEquals(기댓값, Test 메소드) 메소드를 적용하여 결과 확인 -> 프로그램 자동화 가능
<br>

📍 세번째 문제점, 중복 코드
    
    📚 해결 방법 : 중복 코드는 제거하는 것이 좋으므로 Calculator 인스턴스를 상단에 생성, Junit의 @Before 어노테이션을 이용해 단위테스트 실행마다 Calculator을 생성해 준다. 테스트 메소드 실행 시 서로에게 영향을 주지 않기 위해
<br>

---
<br>

## 리팩토링 진행 방법

리팩토링이란 소스코드의 가독성을 높이고 유지보수를 편하게 하기 위해 소스 코드의 구조를 변경하는 것을 의미한다.

- 메소드가 한 가지 책임만 가지도록 구현
- 인텐스(들여쓰기) 깊이를 1단계로 유지할 것. while과 if 문을 사용할 수록 깊이는 1씩 증가
- else를 사용하지 말 것